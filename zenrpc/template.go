package main

import (
	"text/template"
)

var (
	serviceTemplate = template.Must(template.New("service").Parse(`
// generated by zenrpc; DO NOT EDIT

package {{.PackageName}}

import (
	"encoding/json"
	"context"

	"github.com/sergeyfast/zenrpc"
	"github.com/sergeyfast/zenrpc/smd"
)

var RPC = struct {
{{ range .Services}}
	{{.Name}} struct { {{range .Methods }}
		{{.Name}} string {{ end }}
	}
{{ end }}
}{	{{ range .Services}}
		{{.Name}}: struct { {{range .Methods }}
			{{.Name}} string {{ end }}
		}{
		{{range .Methods }}
			{{.Name}}:   "{{.LowerCaseName}}",{{ end }}
		},
	{{ end }}
}

{{ range $s := .Services}}
func ({{.Name}}) SMD() smd.ServiceInfo {
	return smd.ServiceInfo{}
}

// Invoke is as generated code from zenrpc cmd
func (s {{.Name}}) Invoke(ctx context.Context, method string, params json.RawMessage) zenrpc.Response {
	resp := zenrpc.Response{}

	switch method {
	{{range .Methods }}
	case RPC.{{$s.Name}}.{{.Name}}:
		var args = struct {
			{{ range .Args }}
			{{.CapitalName}} {{.Type}} ` + "`json:\"{{.JsonName}}\"`" + ` {{ end }}
		}{}

		if err := json.Unmarshal(params, &args); err != nil {
			return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, err.Error(), nil)
		}

		{{ range .DefaultValues }}
		{{.Comment}}
		if args.{{.CapitalName}} == nil {
			var v {{.Type}} = {{.Value}}
			args.{{.CapitalName}} = &v
		}
		{{ end }}

		resp.Set(s.{{.Name}}({{if .HasContext}}ctx, {{end}} {{ range .Args }}args.{{.CapitalName}}, {{ end }}))
	{{ end }}
	default:
		resp = zenrpc.NewResponseError(nil, zenrpc.MethodNotFound, "", nil)
	}

	return resp
}
{{ end }}
`))
)

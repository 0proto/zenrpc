// generated by zenrpc; DO NOT EDIT

package testdata

import (
	"context"
	"encoding/json"

	"github.com/sergeyfast/zenrpc"
)

// Invoke is as generated code from zenrpc cmd
func (s ArithService) Invoke(ctx context.Context, method string, params json.RawMessage) zenrpc.Response {
	resp := zenrpc.Response{}

	switch method {

	case "divide":
		// A int `json:"a"`
		var args = struct {
			A int `json:"a"`

			B int `json:"b"`
		}{}

		if err := json.Unmarshal(params, &args); err != nil {
			return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, err.Error(), nil)
		}

		resp.Set(s.Divide(args.A, args.B))

	case "multiply":
		// A int `json:"a"`
		var args = struct {
			A int `json:"a"`

			B int `json:"b"`
		}{}

		if err := json.Unmarshal(params, &args); err != nil {
			return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, err.Error(), nil)
		}

		resp.Set(s.Multiply(args.A, args.B))

	case "pow":
		// A int `json:"a"`
		var args = struct {
			Base float64 `json:"base"`

			Exp float64 `json:"exp"`
		}{}

		if err := json.Unmarshal(params, &args); err != nil {
			return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, err.Error(), nil)
		}

		resp.Set(s.Pow(args.Base, args.Exp))

	case "sum":
		// A int `json:"a"`
		var args = struct {
			A int `json:"a"`

			B int `json:"b"`
		}{}

		if err := json.Unmarshal(params, &args); err != nil {
			return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, err.Error(), nil)
		}

		resp.Set(s.Sum(ctx, args.A, args.B))

	case "sumtest":
		// A int `json:"a"`
		var args = struct {
		}{}

		if err := json.Unmarshal(params, &args); err != nil {
			return zenrpc.NewResponseError(nil, zenrpc.InvalidParams, err.Error(), nil)
		}

		resp.Set(s.SumTest())

	default:
		resp = zenrpc.NewResponseError(nil, zenrpc.MethodNotFound, "", nil)
	}

	return resp
}
